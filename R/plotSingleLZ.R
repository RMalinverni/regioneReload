#' plotSingleLZ
#'
#' @description
#'
#' Plot the result of specific local Z-Score tests from an mLZ object in the
#' form of line plot profiles.
#'
#' @details
#'
#' This function generates a line plot with the local Z-score profiles of
#' selected region sets from a multiLocalZscore object. This type of plot
#' complements the local Z-score matrix (generated by
#' \code{\link[RegioneReload]{plotLocalZScoreMatrix}}), since it allows to
#' visualize in detail the local Z-score profile of just the region sets of
#' interest. This plot is well suited for a single or a few region sets, but
#' will get busy if attempting to plot many different profiles. For the latter,
#' the full matrix generated by \code{\link[RegioneReload]{plotLocalZScoreMatrix}})
#' is usually a better visualization option.
#'
#' @usage plotSingleLZ(mLZ, RS, xlab = "", normZS = TRUE, ylim = NULL,
#' main = NA, colPal = NULL, labValues = TRUE, labSize = 2.5, labMax = FALSE,
#' smoothing = FALSE)
#'
#' @param mLZ an object of class multiLocalZscore.
#' @param RS character, vector of region set names for which to plot the local Z-score results.
#' @param xlab character, label for the x axis. (default = NA)
#' @param main character, title for the plot. (default = NA)
#' @param normZS logical, indicates whether the normalized Z-score values should be plotted. If FALSE, the raw Z-score is used. (default = TRUE)
#' @param ylim numeric, vector with minimum and maximum Y values of the plot. If NULL, the plot limits are set by default so all data points can be plotted. (default = NULL)
#' @param labValues logical, if TRUE each local Z-score profile is labelled at position 0 with the name of the region set and its Z-score value at the central position. (default = TRUE)
#' @param labSize numerical, size of the labels from labValues in the plot. (default = 2.5)
#' @param labMax logical, if TRUE the labels are placed at the maximum value of each local Z-score profile instead of shift 0bp. (default = FALSE)
#' @param colPal character vector of custom colors to use as palette source for the plot. If NULL, predetermined colors from \code{\link{RColorBrewer}}) Set2 palette are used.
#' @param smoothing logical, if TRUE \code{\link{stas::smooth.spline}} function will be apply to a localZ-score profile. (default = FALSE)
#' @param ...  further arguments to be passed to other methods.
#'
#' @return A plot is created on the current graphics device.
#'
#' @seealso \code{\link{multiLocalZscore}} \code{\link{makeLZMatrix}}
#'
#' @examples
#'
#' data("cw_Alien")
#'
#' @export plotSingleLZ
#' @import ggplot2
#' @importFrom ggrepel geom_label_repel
#' @importFrom methods hasArg
#' @importFrom RColorBrewer brewer.pal
#' @importFrom methods is
#' @importFrom stats smooth.spline
#' @importFrom stats aggregate


plotSingleLZ <-
  function(mLZ,
           RS,
           xlab = "",
           normZS = TRUE,
           ylim = NULL,
           main = NA,
           colPal = NULL,
           labValues = TRUE,
           labSize = 2.5,
           labMax = FALSE,
           smoothing = FALSE,
           ...) {
    if (!methods::hasArg(mLZ)) {
      stop("mLZ is missing")
    } else if (!methods::is(mLZ, "multiLocalZScore")) {
      stop("mLZ needs to be a multiLocalZScore object")
    } else if (!methods::hasArg(RS)) {
      stop("RS is missing")
    } else if (!(all(RS %in% names(mLZ@multiLocalZscores$shifed_ZSs)))) {
      stop("One or more elements in RS do not match region set names in mLZ")
    }

    RS <- as.list(RS)
    df <- do.call("rbind", lapply(X = RS, FUN = DFfromLZ, mLZ = mLZ))

    ref <- mLZ@parameters$A
    evfun <- mLZ@parameters$evFUN
    ranfun <- mLZ@parameters$ranFUN

    if (is.null(colPal)) { # Palette
      colPal <- RColorBrewer::brewer.pal(n = 5, "Set2")
      pal <- grDevices::colorRampPalette(colPal)
    } else {
      pal <- grDevices::colorRampPalette(colPal)
    }

    if (mLZ@parameters$evFUN == "numOverlaps") {
      mLZ@parameters$evFUN <- "N. of overlaps"
    }

    if (normZS) { # Raw or norm ZS
      df$score <- df$normLocalZscore
      ylabel <- "Normalized Z-score"
    } else {
      df$score <- df$lzscore
      ylabel <- "Z-score"
    }

    if (smoothing == TRUE){
      smth <- stats::smooth.spline(df$score)
      df$score <- smth$y
    }

    # Plot
    p <- ggplot2::ggplot(df, ggplot2::aes_string(x = "shift", y = "score", group = "name", fill = "name", color = "name")) +
      ggplot2::geom_hline(yintercept = 0, color = "#515E63", size = 0.6) +
      ggplot2::geom_vline(xintercept = 0, color = "#515E63", size = 0.4, linetype = "dotted") +
      ggplot2::geom_density(alpha = 0.2, stat = "identity") +
      ggplot2::scale_color_manual(values = pal(length(RS))) +
      ggplot2::scale_fill_manual(values = pal(length(RS))) +
      ggplot2::labs(
        title = ref,
        subtitle = paste("ranFUN: ", ranfun, "\nevFUN: ", evfun),
        y = ylabel,
        x = "bp"
      ) +
      ggplot2::theme(legend.title = ggplot2::element_blank())

    # Labels
    if (labValues) {
      if (labMax) {
        df_label <- merge(stats::aggregate(score ~ name, data = df, FUN = max), df)
        df_label <- df_label[order(df_label$shift),]
        df_label <- df_label[!duplicated(df_label$name),]
      } else {
        df_label <- df[df$shift == 0, ]
      }
      df_label$text <- paste(df_label$name, "\nZS: ", round(df_label$score, digits = 2), sep = "")
      p <- p +
        ggplot2::coord_cartesian(clip = "off") +
        ggrepel::geom_label_repel(
          data = df_label, inherit.aes = FALSE,
          ggplot2::aes_string(label = "text", x = "shift", y = "score", color = "name"),
          fill = "#FDFAF6", size = labSize,
          xlim = c(0.2 * max(df$shift), NA),
          show.legend = FALSE
        )
    }

    # Ylims
    if (!is.null(ylim)) {
      p <- p + ggplot2::coord_cartesian(ylim = ylim)
    }
    p <- p + mendel_theme()
    return(p)
  }
