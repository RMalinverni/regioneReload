---
title: "regioneRld"
author: "roberto Malinverni"
output: BiocStyle::html_document   #rmarkdown::html_vignette
fig_width: 10
fig_height: 10 
vignette: >
  %\VignetteIndexEntry{regioneRld}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
 fig.width=6, 
 fig.height=6,
 fig.align = "center"
)
```

```{r style, echo = FALSE, results = 'asis'}
BiocStyle::markdown()
```

# regioneRld

The meaningful interpretation of overlaps between binding profiles of multiple 
chromatin regulators is a major challenge in epigenomics. To address this, 
in 2015 we published `r BiocStyle::Biocpkg("regioneR")` an R package that we developed for the statistical  
assessment of the association between genomic regions sets. One limitation of regioneR is that it can only
perform association analyisis between two region sets at a time. Here, we now present  
**regioneRld**, an R package that is the natural evolution of `r BiocStyle::Biocpkg("regioneR")` and allows to 
calculate the statistical association between multiple regions sets at the same 
time. To compare z-scores coming from multiple analysis, different 
strategies have been introduced to normalize the z-score and to improve the 
p-value calculations. Taken together, regioneRld aims to be a novel and precious 
addition to NGS tools and for whole genome analysis.

## regioneR limitations

`r BiocStyle::Biocpkg("regioneR")` is an R package created to test the associations between genomic region 
sets. The core of `r BiocStyle::Biocpkg("regioneR")` is a permutation test framework specifically designed 
to work in a genomic environment. The two main results that can be obtained with this method can be summarized in two 
graphs. Figure 1A shows the association observed between the two region sets under study, 
highlighting the distance calculated in standard deviations from the random 
distribution. Figure 1B shows the local z-score: a narrow peak, as the one shown, indicates that the 
association is highly dependent on the exact location of the region. One the contrary, a flat profile would suggest a 
regional association.

<!-- This section is titled regioneR limitations but it does not address this point directly. 
Either highlight the limitation of pairwise comparisons or change the title? -->

<!-- Missing Figure -->
(figure 1)

## Normalized Z-Score

regioneRld aims to integrate the framework previously developed for `r BiocStyle::Biocpkg("regioneR")`, 
to calculate associations of different region sets simultaneously. To compare
associations deriving from different region sets, we introduce the concept of 
**normalized z-score**, which allows not only to compare different association 
events but also to work with subsets of data and speed up the calculations.
<!-- Explain what exactly the nZS corrects? I mean, describe what is the statistical/mathematical limitation that it aims to solve.
The dependency of the ZS value on the number of regions in the region sets tested? -->
The normalized Z-Score is calculated as follows:

nZS = ZS / $\sqrt{n}$

<!-- Missing Figure -->
(figure 2)

# Quick start

```{r setup}
library("regioneRld")
```
<!-- Consider moving this to the Crosswise Analysis section -->
The permutation test can be performed on a list multiple region sets by the function `crosswisePermTest()`.
This process is computing intensive and its calculation time depends on the 
number of cores called by the parameter `mc.cores` (see `r BiocStyle::Biocpkg("regioneR")`).
The result of the permutation test obtained by running the code below is included as a pre-computed example dataset
which can be loaded into the environment by running the command `data("cw_Alien_RaR")`.

`AlienGenome` and `AlienRSList` are described in the next section of the vignette. 

```{r load _data, eval=FALSE}
#NOT RUN
  set.seed(42)
  cw_Alien_ReG<-crosswisePermTest(Alist = AlienRSList,
                            sampling = FALSE,
                            mc.cores= 25,
                            ranFUN = "resampleGenome",
                            evFUN = "numOverlaps",
                            genome = AlienGenome,
                            ntimes= 1000
  )
#
```

```{r}
library(regioneR)
library(RColorBrewer) # now we can delete this

data("cw_Alien")


cw_Alien_ReG<-makeCrosswiseMatrix(cw_Alien_ReG, pvcut = 1)

plotCrosswiseMatrix(cw_Alien_ReG, matrix.type = "crosswise")

plotCrosswiseMatrix(cw_Alien_ReG, matrix.type = "correlation")
```
<!-- Briefly describe the plots? -->

## Alien Genome and Alien RegionSet List

Calculating the associations between genomic region sets can be very time consuming. We have created a fake "AlienGenome" consisting of
four chromosomes to reduce the calculation time for testing and understanding the results generated by regioneRld.

![Graphical descrition of the AlienGenome](figures/AlienGenDesc.png){width=85%}

```{r}

library("regioneRld")

```


```{r}

AlienGenome <-
  toGRanges(data.frame(
    chr = c("AlChr1", "AlChr2", "AlChr3", "AlChr4"),
    start = c(rep(1, 4)),
    end = c(1e4, 2e3, 1e3, 5e3)
  ))

```

From this AlienGenome, we define 3 random RegionSet using `createRandomRegions`. 
Each region set consists of 100 regions and are called "regA", "regB" and "regC" with a mean length of 50bp.

```{r}
gnm <- AlienGenome

nreg=100

regA <-
  createRandomRegions(
    nregions = nreg,
    length.mean = 50,
    length.sd = 5,
    non.overlapping = TRUE,
    genome = gnm
  )

regB <-
  createRandomRegions(
    nregions = nreg,
    length.mean = 50,
    length.sd = 5,
    non.overlapping = TRUE,
    genome = gnm
  )

regC <-
  createRandomRegions(
    nregions = nreg,
    length.mean = 50,
    length.sd = 5,
    non.overlapping = TRUE,
    genome = gnm
  )

```

To generate "artificial" associations we can use the function `similarRegionSet()`, which produces random region sets with a certain degree of similarity.
For each region set regA, regB and regC, we create a list of region sets that share a percentage (from 90% to 10%) of regions with the original one.

```{r}

vectorPerc <- seq(0.1, 0.9, 0.1)

RsetA <-
  similarRegionSet(
    GR = regA,
    name = "regA",
    genome = gnm,
    vectorPerc = vectorPerc
  )
RsetB <-
  similarRegionSet(
    GR = regB,
    name = "regB",
    genome = gnm,
    vectorPerc = vectorPerc
  )
RsetC <-
  similarRegionSet(
    GR = regC,
    name = "regC",
    genome = gnm,
    vectorPerc = vectorPerc
  )

```

We then create a RegionSet that shares half the regions of regA and half of regB and call it regAB. 
From this RegionSet we create again similar region sets using `similarRegionSet()`.

```{r}
vectorPerc2 <- seq(0.2, 0.8, 0.2)
regAB <- c(sample(regA, nreg / 2), sample(regB, nreg / 2))
RsetAB <-
  similarRegionSet(
    GR = regAB,
    name = "regAB",
    genome = gnm,
    vectorPerc = vectorPerc2
  )

```

As a last step, we create random RegionSets that do **not** contain regions of regA, regB, regC or regAB.
Finally, we store all the generated region sets in a list called `AlienRSList`.

```{r}
reg_no_A <-
  createRandomRegions(
    nregions = nreg,
    length.mean = 10,
    length.sd = 5,
    non.overlapping = TRUE,
    genome = subtractRegions(gnm, regA)
  )

reg_no_B <-
  createRandomRegions(
    nregions = nreg,
    length.mean = 10,
    length.sd = 5,
    non.overlapping = TRUE,
    genome = subtractRegions(gnm, regB)
  )

reg_no_C <-
  createRandomRegions(
    nregions = nreg,
    length.mean = 10,
    length.sd = 5,
    non.overlapping = TRUE,
    genome = subtractRegions(gnm, regC)
  )
reg_no_AB <-
  createRandomRegions(
    nregions = nreg,
    length.mean = 10,
    length.sd = 5,
    non.overlapping = TRUE,
    genome = subtractRegions(gnm, c(regA, regB))
  )

Rset_NO <- list(reg_no_A, reg_no_B, reg_no_C, reg_no_AB)

names(Rset_NO) <- c("reg_no_A", "reg_no_B", "reg_no_C", "reg_no_AB")

RsetAB <-
  similarRegionSet(
    GR = regAB,
    name = "regAB",
    genome = gnm,
    vectorPerc = vectorPerc2
  )

AlienRSList <- c(RsetA, RsetB, RsetC, RsetAB, Rset_NO)

summary(AlienRSList)

```

## Multi Permutation Test 
### Crosswise Analysis

`crosswisePermTest()` is the core statistical function of the package. This function calculates the permutation test between all possible combination
pairs in a list of region sets. The result of this function is an S4 object of class gMXR that contains three slots: *parameteres*, *multiOverlaps* and *matrix*.

* gMXR_obj
  + @parameters
    + Alist
    + Blist
    + sampling
    + fraction
    + min_sampling
    + ranFUN
    + evFUN
    + universe
    + adj_pv_method
    + max_pv
    + nc
    + matOrder
    + ntimes
  + @multiOverlaps
    + one field for each comparison
  + @matrix
    + GMat
    + GMat_pv
    + GMat_corX
    + GMat_corY
    + FitRow
    + FitCol


#### Parameters

The slot "parameters" stores all the parameters used to obtain  the gMXR object.

```{r }
data("cw_Alien")
print(cw_Alien_ReG@parameters)
```

#### multiOverlaps
<!-- The concept of Alist and Blist have not been introduced before this point, explain in the intro to the crosswiseAnalysis or in the example function call. -->
The "multiOverlaps" slot contains a list of data frames. For each element of the list of region sets "Alist", a data frame with 12 columns and a number of rows equal to the elements in Blist. The columns of the data frame contain the following information:

+ order.id:       order of comparison
+ name:           name of Blist element 
+ n_regionA       number of regions in Alist using in the permutation test
+ n_regionB       number of regions in Blist using in the permutation test
+ z_score         calculated z-score of permutation test
+ p_value         p.value of permutation test
+ n_overlaps      number of overlaps between Alist element and Belement (change name) 
+ mean_perm_test  mean of overlaps of the permutated region set
+ sd_perm_test    standard deviation of hits in permutated region set
+ norm_zscore     z-scores normalized
+ std_zscore      z-score standardized* (maybe is better to eliminate)
+ adj_p_value     p.value adjusted 


```{r}
print(head(cw_Alien_ReG@multiOverlaps$regA01))
print(cw_Alien_ReG)
```

#### matrix

When the gMXR object is first created, the "matrix" slot will have a NULL value.
<!-- Explain here how to create the matrix, what is its purpose or where is this explained? -->

```{r}
str(cw_Alien_ReG@matrix)
```

### Evaluation functions
regioneReload can use all the evaluation strategies present in
`r BiocStyle::Biocpkg("regioneR")`.

### Randomization functions

regioneReload can use all the randomization strategies present in
`r BiocStyle::Biocpkg("regioneR")` 
(adding phrases for new approach of resampleRegions)
```{r, eval=FALSE}
#NOT RUN

set.seed(42)
cw_Alien_RaR <-  crosswisePermTest(
                          Alist = AlienRSList,
                          Blist = AlienRSList,
                          sampling = FALSE, 
                          genome = AlienGenome,
                          per.chromosome=TRUE,
                          ranFUN = "randomizeRegions",
                          evFUN = "numOverlaps",
                          ntimes= 1000,
                          mc.cores = 25
                          )

set.seed(42)
cw_Alien_ReG <-  crosswisePermTest(
                        Alist = AlienRSList,
                        Blist = AlienRSList,
                        sampling = FALSE, 
                        genome = AlienGenome,
                        ranFUN = "resampleGenome",
                        evFUN = "numOverlaps",
                        ntimes= 1000,
                        mc.cores = 25
                        )
set.seed(42)
cw_Alien_cRaR <-  crosswisePermTest(
                        Alist = AlienRSList,
                        Blist = AlienRSList,
                        sampling = FALSE, 
                        genome = AlienGenome,
                        ranFUN = "circularRandomizeRegions",
                        evFUN = "numOverlaps",
                        ntimes= 1000,
                        mc.cores = 25
                      )
set.seed(42)
cw_Alien_ReR <-  crosswisePermTest(
                        Alist = AlienRSList,
                        Blist = AlienRSList,
                        sampling = FALSE, 
                        genome = AlienGenome,
                        ranFUN = "resampleRegions",
                        evFUN = "numOverlaps",
                        ntimes= 1000,
                        mc.cores = 25
                      )
#

```

Using default option the matrix clusterization will be automatic selected 

```{r}
#cw_Alien_RaR <- makeCrosswiseMatrix(cw_Alien_RaR)

cw_Alien_ReG <- makeCrosswiseMatrix(cw_Alien_ReG)

#cw_Alien_cRaR <- makeCrosswiseMatrix(cw_Alien_cRaR)

#cw_Alien_ReR <- makeCrosswiseMatrix(cw_Alien_ReR)
```

To compare the output of the matrices created with different randomization functions, 
we need to fix the clusterization

```{r}

X<-rownames(cw_Alien_ReG@matrix$GMat)
Y<-colnames(cw_Alien_ReG@matrix$GMat)
ord<-list(X=X,Y=Y)

#plotCrosswiseMatrix(cw_Alien_RaR,matrix.type = "crosswise",maxVal = 0.7,ord_mat = ord)
plotCrosswiseMatrix(cw_Alien_ReG,matrix.type = "crosswise" ,ord_mat = ord)
#plotCrosswiseMatrix(cw_Alien_cRaR,matrix.type = "crosswise",maxVal = 0.7,ord_mat = ord)
#plotCrosswiseMatrix(cw_Alien_ReR,matrix.type = "crosswise",maxVal = 0.7,ord_mat = ord)

#plotCrosswiseMatrix(cw_Alien_RaR,matrix.type = "correlation",maxVal = 0.7,ord_mat = ord)
plotCrosswiseMatrix(cw_Alien_ReG,matrix.type =  "correlation" ,ord_mat = ord)
#plotCrosswiseMatrix(cw_Alien_cRaR,matrix.type =  "correlation",maxVal = 0.7,ord_mat = ord)
#plotCrosswiseMatrix(cw_Alien_ReR,matrix.type =  "correlation",maxVal = 0.7,ord_mat = ord)

```

## Plot Single permutation test result

with the function plotSinglePT is possible to plot the association between two regions set form a gMXR object


```{r}
plotSinglePT(cw_Alien_ReG, RS1 = "regA","regA05")

plotSinglePT(cw_Alien_ReG, RS1 = "regA","regC")

plotSinglePT(cw_Alien_ReG, RS1 = "regA","reg_no_A")
```

## Plot Dimensionally Reduction
```{r}
cw_Alien_ReG_s <- makeCrosswiseMatrix(cw_Alien_ReG,scale = TRUE)

set.seed(67)
plotCrosswiseDimRed(cw_Alien_ReG_s, nc = 5, type="PCA")
```

```{r}
set.seed(67)
plotCrosswiseDimRed(cw_Alien_ReG_s, nc = 5, type="PCA",ellipse = TRUE)
```

```{r}
lsRegSet<-list(regA="regA",regB="regB",regC="regC")

set.seed(67)
plotCrosswiseDimRed(cw_Alien_ReG_s, nc = 5, type="PCA",listRS = lsRegSet)

set.seed(67)
plotCrosswiseDimRed(cw_Alien_ReG_s, nc = 5, type="PCA",listRS = lsRegSet,ellipse = TRUE, emphasize =TRUE)
```

```{r}
set.seed(67)
plotCrosswiseDimRed(cw_Alien_ReG_s, nc = 5, type="tSNE",listRS = lsRegSet,ellipse = TRUE, emphasize =TRUE)
```

```{r}
set.seed(67)
plotCrosswiseDimRed(cw_Alien_ReG_s, nc = 5, type="UMAP",listRS = lsRegSet,ellipse = TRUE, emphasize =TRUE)

```


# Multi Local Zscore

Descrizione

```{r, eval=FALSE }

#NOT RUN
mlz_Alien_ReG<-multiLocalZscore(A = AlienRSList$regA,
                 Blist = AlienRSList,
                 ranFUN = "resampleGenome",
                 evFUN = "numOverlaps",
                 window = 100,
                 step = 1,
                 max_pv =1,
                 genome = AlienGenome,
                 mc.cores = 25)
```

```{r, eval=FALSE }
str(mlz_Alien_ReG)
```
creare la matrice

```{r}
mlz_Alien_ReG <- makeLZMatrix(mlz_Alien_ReG)

```
plotting
```{r }
plotLocalZScoreMatrix(mlz_Alien_ReG, maxVal = "max")
```
