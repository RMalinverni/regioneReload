---
title: "regioneReloaded"
author: "Roberto Malinverni"
output: BiocStyle::html_document   #rmarkdown::html_vignette
fig_width: 10
fig_height: 10 
vignette: >
  %\VignetteIndexEntry{regioneReloaded}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
 fig.width=6, 
 fig.height=6,
 fig.align = "center"
)
```

```{r style, echo = FALSE, results = 'asis'}
BiocStyle::markdown()
```

# regioneReload

The meaningful interpretation of overlaps between binding profiles of multiple 
chromatin regulators is a major challenge in epigenomics. To address this, 
in 2015 we published `r BiocStyle::Biocpkg("regioneR")`, an R package that we developed for the statistical
assessment of the association between genomic regions sets. One limitation of regioneR is that it can only
perform association analyisis between two region sets at a time. Here, we now present 
**regioneReload**, an R package that is the natural evolution of `r BiocStyle::Biocpkg("regioneR")` and allows to  calculate the statistical association between multiple regions sets at the same time. To compare z-scores coming from multiple analysis, different strategies have been introduced to normalize the z-score and to improve the 
p-value calculations. regioneReload also improves `r BiocStyle::Biocpkg("regioneR")` by adding new randomization methods and different functions for obtaining publication-ready graphs. Taken together, regioneReload aims to be a novel and precious addition to NGS tools and for whole genome analysis.

## regioneR limitations

`r BiocStyle::Biocpkg("regioneR")` is an R package created to test the associations between genomic region sets. The core of `r BiocStyle::Biocpkg("regioneR")` is a permutation test framework specifically designed to work in a genomic environment. The two main results that can be obtained with this method can be summarized in two graphs. Figure 1A shows the association observed between the two region sets under study, highlighting the distance calculated in standard deviations from the random distribution. Figure 1B shows the local z-score: a narrow peak, as the one shown, indicates that the association is highly dependent on the exact location of the region. One the contrary, a flat profile would suggest a regional association.

<!-- This section is titled regioneR limitations but it does not address this point directly. 
Either highlight the limitation of pairwise comparisons or change the title? -->


(figure 1)

![regioneR basic Graphs](figures/regioner_grphs.png){width=120%}

## Normalized Z-Score

regioneReload aims to integrate the framework previously developed for `r BiocStyle::Biocpkg("regioneR")` 
to calculate associations of different region sets simultaneously. To compare
associations deriving from different region sets, we introduce the concept of 
**normalized z-score**, which allows not only to compare different association 
events but also to work with subsets of data and speed up the calculations.
To compare different z-scores is necessary to normalize them. The values of z-score of different test is not possible to compare.In particular z-score is directly associate to the square root of the  number of regions present in RS1.
If we empirically evaluate the value of normal z-score using different number of regions.
<!-- Explain what exactly the nZS corrects? I mean, describe what is the statistical/mathematical limitation that it aims to solve.
The dependency of the ZS value on the number of regions in the region sets tested? -->
The normalized Z-Score is calculated as follows:

nZS = ZS / $\sqrt{n}$


![local zscore  colculation (provisional)](figures/normal_ZScore.png){width=90%}

The normal z-score was stabilized using 30% of the sample, this can be used to reduce the calculation time.
<!-- Missing Figure -->
![local zscore  colculation (provisional)](figures/ntimes_stabilizations.png){width=90%}
Other crucial factor for calculate the normal z-score is the ntime, the suggestion after our tests is to use a minimum of 5000 permutation to achieve a reproducible results.

# Quick start

```{r setup}
library("regioneReloaded")
```
<!-- Consider moving this to the Crosswise Analysis section -->
The permutation test can be performed on a list multiple region sets by the function `crosswisePermTest()`.
This process is computing intensive and its calculation time depends on the 
number of cores called by the parameter `mc.cores` (see `r BiocStyle::Biocpkg("regioneR")`).
The result of the permutation test obtained by running the code below is included as a pre-computed example dataset
which can be loaded into the environment by running the command `data("cw_Alien_RaR")`.

`AlienGenome` and `AlienRSList` are described in the next section of the vignette. 

```{r load _data, eval=FALSE}
#NOT RUN
  
  set.seed(42)
  cw_Alien_ReG<-crosswisePermTest(Alist = AlienRSList_narrow,
                            sampling = FALSE,
                            mc.cores= 25,
                            ranFUN = "resampleGenome",
                            evFUN = "numOverlaps",
                            genome = AlienGenome,
                            ntimes= 1000
  )
#
```

```{r}

data("cw_Alien")


cw_Alien_ReG<-makeCrosswiseMatrix(cw_Alien_ReG, pvcut = 1)

plotCrosswiseMatrix(cw_Alien_ReG, matrix_type = "association")

plotCrosswiseMatrix(cw_Alien_ReG, matrix_type = "correlation")
```
<!-- Briefly describe the plots? -->

## Alien Genome and Alien RegionSet List

Permutation test of regions set on a eukaryotic genome can take a long time. To show the different regionReloaded features, a fake genome called the 'AlienGenome' was created to overcome this problem. This genome consists of four chromosomes of different lengths ranging from 2Mb to 0.1Mb.

![Graphical descrition of the AlienGenome](figures/AlienGenome_scheme.png){width=100%}

```{r}

AlienGenome <-
  toGRanges(data.frame(
    chr = c("AlChr1", "AlChr2", "AlChr3", "AlChr4"),
    start = c(rep(1, 4)),
    end = c(2e6, 1e6, 5e5, 1e5)
  ))


```

Four basic region sets were created on this genome. The first three ("regA", "regB", "regC"), were created using the function in the regionR package `createRandomRegions`. Each Regions set consists of 100 regions with an average width of 100 bp (the widths of the regions will have a standard deviation of 50 bp). Being randomly originated, the three regions sets should show no associations with each other.


```{r}
gnm <- AlienGenome

nreg=100

regA <-
  createRandomRegions(
    nregions = nreg,
    length.mean = 100,
    length.sd = 50,
    non.overlapping = TRUE,
    genome = gnm
  )

regB <-
  createRandomRegions(
    nregions = nreg,
    length.mean =  100,
    length.sd = 50 ,
    non.overlapping = TRUE,
    genome = gnm
  )

regC <-
  createRandomRegions(
    nregions = nreg,
    length.mean = 100,
    length.sd = 50,
    non.overlapping = TRUE,
    genome = gnm
  )

```

To generate "artificial" associations we can use the `similarRegionSet()` function, which produces sets of random regions with some degree of similarity to the original. For each set of regions regA, regB and regC, we create a list of region sets that share a percentage (90% to 10%) of regions with the original set.

```{r}

vectorPerc <- seq(0.1, 0.9, 0.1)

RsetA <-
  similarRegionSet(
    GR = regA,
    name = "regA",
    genome = gnm,
    vectorPerc = vectorPerc
  )
RsetB <-
  similarRegionSet(
    GR = regB,
    name = "regB",
    genome = gnm,
    vectorPerc = vectorPerc
  )
RsetC <-
  similarRegionSet(
    GR = regC,
    name = "regC",
    genome = gnm,
    vectorPerc = vectorPerc
  )

```

Next we create a RegionSet of 100 regions which shares half the regions of regA and half of regB called regAB.  From this RegionSet we create similar region sets again using `similarRegionSet()`.

```{r}

vectorPerc2 <- seq(0.2, 0.8, 0.2)
regAB <- c(sample(regA, nreg / 2), sample(regB, nreg / 2))
RsetAB <-
  similarRegionSet(
    GR = regAB,
    name = "regAB",
    genome = gnm,
    vectorPerc = vectorPerc2
  )

```

As a negative count of, we create sets of random regions that contain no regions of regA, regB, regC, regAB or no regions of the preceding regABC.

```{r}

reg_no_A <-
  createRandomRegions(
    nregions = nreg,
    length.mean = 100,
    length.sd = 50,
    non.overlapping = TRUE,
    genome = subtractRegions(gnm, regA)
  )

reg_no_B <-
  createRandomRegions(
    nregions = nreg,
    length.mean = 100,
    length.sd = 50,
    non.overlapping = TRUE,
    genome = subtractRegions(gnm, regB)
  )

reg_no_C <-
  createRandomRegions(
    nregions = nreg,
    length.mean = 100,
    length.sd = 50,
    non.overlapping = TRUE,
    genome = subtractRegions(gnm, regC)
  )
reg_no_AB <-
  createRandomRegions(
    nregions = nreg,
    length.mean = 100,
    length.sd = 50,
    non.overlapping = TRUE,
    genome = subtractRegions(gnm, c(regA, regB))
  )

reg_no_ABC <-
  createRandomRegions(
    nregions = nreg,
    length.mean = 100,
    length.sd = 50,
    non.overlapping = TRUE,
    genome = subtractRegions(gnm, c(regA, regB, regC))
  )

```

To evaluate the "lateral" association (association with a region close to the one being tested), the Regions Set "regD" was created. It is associated with regions in the vicinity of Region Set "regA" but not with the Regions Set itself.

```{r}

dst <- sample(c(-300,300),length(regA),replace = TRUE)
regD <- regioneR::toGRanges(
                    data.frame(
                      chr=as.vector(GenomeInfoDb::seqnames(regA)),
                      start = start(regA) + dst,
                      end = end (regA) + dst
                      )
                    )

RsetD <-
  similarRegionSet(
    GR = regD,
    name = "regD",
    genome = gnm,
    vectorPerc = vectorPerc2
  )

```

Finally, we store all the generated sets of regions in a list called `AlienRSList` which we can use as input for the `crosswisePermTest()` function.

```{r}

Rset_NO <- list(reg_no_A, reg_no_B, reg_no_C, reg_no_AB, reg_no_ABC)

names(Rset_NO) <- c("reg_no_A", "reg_no_B", "reg_no_C", "reg_no_AB", "reg_no_ABC")



AlienRSList_narrow <- c(RsetA, RsetB, RsetC, RsetD, RsetAB, Rset_NO)

summary(AlienRSList_narrow)

```

## Multi Permutation Test 
### Crosswise Analysis

`crosswisePermTest()` is the main statistical function of the package. Crosswise analysis means the calculation of permutation tests between all possible combinations of a set of `Alist` regions with a second set of `Blist` regions. 
The result of `crosswisePermTest()` is an S4 object of class `genoMatriXeR` that contains three slots: *parameters*, *multiOverlaps* and *matrix*.

* gMXR_obj
  + @parameters
    + Alist
    + Blist
    + sampling
    + fraction
    + min_sampling
    + ranFUN
    + evFUN
    + universe
    + adj_pv_method
    + max_pv
    + nc
    + matOrder
    + ntimes
  + @multiOverlaps
    + one field for each comparison
  + @matrix
    + GMat
    + GMat_pv
    + GMat_corX
    + GMat_corY
    + FitRow
    + FitCol


#### Parameters

The slot "parameters" stores all the parameters used to obtain the genomicMatriXer object.

```{r }

data("cw_Alien")
getParameters(cw_Alien_ReG)

```

#### multiOverlaps
<!-- The concept of Alist and Blist have not been introduced before this point, explain in the intro to the crosswiseAnalysis or in the example function call. -->
The "multiOverlaps" slot contains a list of data frames. For each element of the list of region sets "Alist", a data frame is stored with 11 columns and a number of rows equal to the elements in "Blist". The columns of the data frame contain the following information:

+ **order.id:**       order of comparison
+ **name:**           name of Blist elements 
+ **n_regionA:**       number of permuted Alist regions.
+ **n_regionB:**       number of regions in each regions set of Blist 
+ **z_score:**         z-score calculated by [regioneR::permTest()]
+ **p_value:**         p.value calculated by [regioneR::permTest()]
+ **n_hits:**          number of hits computed using the evaluation function on a regions set of Alist versus each regions set of Blists
+ **mean_perm_test:**  mean of hits computed using the evaluation function on the permutated region set
+ **sd_perm_test:**    standard deviation of hits computed using the evaluation function on the permutated region set
+ **norm_zscore:**     normalized z-scores 
+ **adj_p_value:**     adjusted p.value 


```{r}

print(cw_Alien_ReG)

```

#### matrix


When the genoMatriXeR object is created, the "matrix" slot will have a NULL value. 


### Evaluation functions
regioneReload can use all the evaluation strategies present in
`r BiocStyle::Biocpkg("regioneR")`, it also allows the use of custom functions, as far as the examples considered by this vignette will be based on the default evaluation function [numOvelaps] [regionR::numOverlaps]

### Randomization functions

regioneReload can use all the randomization strategies present in
`r BiocStyle::Biocpkg("regioneR")` and  it also allows the use of custom functions.

differently from regionR the randomization function [resampleRegions][regioner::resampleRegions] can work without the presence of the parameter "universe". In this case a "universe" will be created by using all regions from the list of regions set "Alist" using the function [createUniverse].


```{r, eval=FALSE}

#NOT RUN

set.seed(42)
cw_Alien_RaR <-  crosswisePermTest(
  Alist = AlienRSList_narrow,
  Blist = AlienRSList_narrow,
  sampling = FALSE,
  genome = AlienGenome,
  per.chromosome=TRUE,
  ranFUN = "randomizeRegions",
  evFUN = "numOverlaps",
  ntimes= 1000,
  mc.cores = 20
)


set.seed(42)
cw_Alien_ReR <-  crosswisePermTest(
  Alist = AlienRSList_narrow,
  Blist = AlienRSList_narrow,
  sampling = FALSE,
  genome = AlienGenome,
  per.chromosome=TRUE,
  ranFUN = "resampleRegions",
  evFUN = "numOverlaps",
  ntimes= 1000,
  mc.cores = 20
)

set.seed(42)
cw_Alien_ReG <-  crosswisePermTest(
  Alist = AlienRSList_narrow,
  Blist = AlienRSList_narrow,
  sampling = FALSE,
  genome = AlienGenome,
  per.chromosome=TRUE,
  ranFUN = "resampleGenome",
  evFUN = "numOverlaps",
  ntimes= 100,
  mc.cores = 20
)

#

```


### Matrix Calculation

the association matrix will be computed with the function [makeCrosswiseMatrix]. This function returns the object with the matrix assigned to the "matrix" slot, the matrix will be able to be queried with the [getMatrix] function. As a default value the matrix will be created using *normalized z-score* for a more in-depth description of the parameters that can be used to create the matrix we refer you to the [makeCrosswiseMatrix] function manual. If no clustering method is chosen for the array, automatically the most efficient clustering method will be chosen from those in [hclust], as described in the [chooseHclustMet] function manual.



```{r}

cw_Alien_RaR <- makeCrosswiseMatrix(cw_Alien_RaR)

cw_Alien_ReG <- makeCrosswiseMatrix(cw_Alien_ReG)

cw_Alien_ReR <- makeCrosswiseMatrix(cw_Alien_ReR)

```

To compare the output of the matrices created with different randomization functions, we need to use the fixed order of clusterization for all matrices. 

```{r}

modX <- getHClust(cw_Alien_ReG,hctype = "rows")
modY <- getHClust(cw_Alien_ReG,hctype = "cols")



X<-modX$labels[modX$order]
Y<-modY$labels[modX$order]

ord<-list(X=X,Y=Y)

p_ReG <- plotCrosswiseMatrix(cw_Alien_ReG, matrix_type = "association", ord_mat = ord)
p_ReR <- plotCrosswiseMatrix(cw_Alien_ReR, matrix_type = "association", ord_mat = ord)


plot(p_ReG)
plot(p_ReR)

```

getHClust] function returns an object of class [hclust] that you can use for furher analysis.

```{r}

plot(modX)

```

the *matrix_type* parameter [plotCrosswiseMatrix] allows to choose between "association" matrix (where the z-score value obtained from the permutation test calculation will be shown), or "correlation" (where the Pearson's R-value between each Regions Set will be used).

```{r}

p_ReG_cor <- plotCrosswiseMatrix(cw_Alien_ReG, matrix_type = "correlation", ord_mat = ord)
p_ReR_cor <- plotCrosswiseMatrix(cw_Alien_ReR, matrix_type = "correlation", ord_mat = ord)

plot(p_ReG_cor)
plot(p_ReR_cor)

```



## Plot Single permutation test 

[regionReloded] allows us to extract and visualize the results of a single Region Sets comparison, the visualization resumes the previous graphs in [regioneR] by exploiting the power of [ggplot2].

```{r}
plotSinglePT(cw_Alien_ReG, RS1 = "regA", RS2 = "regA_05")
```

```{r}
p_sPT1 <- plotSinglePT(cw_Alien_ReG, RS1 = "regA", RS2 = "regC")

plot(p_sPT1)
```

## Plot Dimensionally Reduction

Dimensionality reduction refers to a strategy capable of representing complex (high-density) data in a low-density space while retaining some meaningful properties of the original data. The plotCrosswiseDimRes function allows three of the most widely used algorithms (PCA, tRSNE, UMAP) to be applied to represent genoMatriXeR objects.


```{r}

set.seed(42)

plotCrosswiseDimRed(cw_Alien_ReG, nc = 6, type="PCA")

```

The data is clustered using a clustering algorithm that can be selected from ("hclust", "kmeans" or "pam" ), giving the possibility of importing an external clustering method.

```{r}
set.seed(42)
p_cdr_hc <- plotCrosswiseDimRed(cw_Alien_ReG, nc = 6, type="PCA", clust_met = "hclust")

set.seed(42)
p_cdr_pam <- plotCrosswiseDimRed(cw_Alien_ReG, nc = 6, type="PCA", clust_met = "pam")

plot(p_cdr_hc) 
plot(p_cdr_pam)
          
```

The parameters *listRS* and *emphasize* were added to emphasise the data found to be interesting.

```{r}

lsRegSet<-list(regA="regA",regB="regB",regC="regC")

set.seed(42)
plotCrosswiseDimRed(cw_Alien_ReG, nc = 6, type="PCA",listRS = lsRegSet)

set.seed(42)
plotCrosswiseDimRed(cw_Alien_ReG, nc = 6, type="PCA",listRS = lsRegSet,ellipse = TRUE, emphasize =TRUE)

set.seed(67)
plotCrosswiseDimRed(cw_Alien_ReG, nc = 6, type="tSNE",listRS = lsRegSet,ellipse = TRUE, emphasize =TRUE)

set.seed(67)
plotCrosswiseDimRed(cw_Alien_ReG, nc = 6, type="UMAP",listRS = lsRegSet,ellipse = TRUE, emphasize =TRUE)

```
The * return_table* parameter displays a table summarising the results of the clustering, incorporating the value *ASW* total mean of individual silhouette widths [silohuette][cluster::silhouette].

```{r}
set.seed(67)
silTable <- plotCrosswiseDimRed(cw_Alien_ReG, nc = 6, type="UMAP",listRS = lsRegSet,return_table = TRUE)

silTable
```

# Multi Local Zscore

The [multiLocalZscore] function allows the association of a single regions Set against a list of regions Sets to be analysed by applying the [localZScore][regioner::localZScore] function in a neighbourhood defined by the *window* parameter a number of times defined by the *step* parameter.

```{r, eval=FALSE }

#NOT RUN
mlz_Alien_ReG<-multiLocalZscore(A = AlienRSList_narrow$regA,
                 Blist = AlienRSList_narrow,
                 ranFUN = "resampleGenome",
                 evFUN = "numOverlaps",
                 window = 100,
                 step = 1,
                 max_pv = 1,
                 genome = AlienGenome)
```


As with the [crosswisePermTest] function, an object consisting of three slots *paremeters* *multiLocalZscores* and *matrix* will be created. These can be queried by the functions [getParametrs], [getMultiEvaluation] and [getMatrix] respectively. Again, the object thus created will have the matrix slot = NULL.

```{r}
getParameters(mLZ_regA_ReG)

mlz_Me <- getMultiEvaluation(rR = mLZ_regA_ReG )

mlz_Me$resumeTable
```

The matrix will be created by the function [makeLZMatrix] in a similar manner as illustrated for the function [makeCrosswiseMatrix]. Again, it is possible to pass a clustering method to the function, and if not, the best clustering function calculated using [chooseHclustMet] will be chosen.

```{r}

mLZ_regA_ReG <- makeLZMatrix(mLZ_regA_ReG)

plot(getHClust(mLZ_regA_ReG))
```
The [plotLocalZScoreMatrix] function allows the visualisation of an object of class [multilocalZScore]. This type of visualisation will also allow the association to be tested in the area adjacent to the tested Region Set. 

```{r}
plotLocalZScoreMatrix(mLZ_regA_ReG, maxVal = "max")
```

# Analyses of non-square matrices

regionReloaded allows the association of Regions Sets of any length to be calculated. AlienRSList_broad is a list of Regions Set created from AlienRSList_narrow, in which the [extendRegions][regionR::extendRegions] function has increased the width to an average of 5kb and added a completely random list of Regions Set (RegR).
```{r}
# average of the widths of AlienRSList_narrow
do.call("c",lapply(lapply(AlienRSList_narrow, width),mean))
# average of the widths of AlienRSList_broad
do.call("c",lapply(lapply(AlienRSList_broad, width),mean))
```
```{r eval=FALSE}

##NOT RUN
cw_Alien_RaR_no_Square <-  crosswisePermTest(
  Alist = AlienRSList_narrow,
  Blist = AlienRSList_broad,
  sampling = FALSE,
  genome = AlienGenome,
  per.chromosome=TRUE,
  ranFUN = "resampleGenome",
  evFUN = "numOverlaps",
  ntimes= 100,
  mc.cores = 6
)

###
```

the matrix calculated in this case is based on a double clustering of rows and columns

```{r}
cw_Alien_ReG_no_Square <- makeCrosswiseMatrix(cw_Alien_ReG_no_Square)

plotCrosswiseMatrix(cw_Alien_ReG_no_Square)
```

In this case, the [multiLocalZscore] function works in exactly the same way as in the previous cases, but in order to see the form of the association, it is recommended to enlarge the *windows*.

```{r, eval=FALSE}

#NOT RUN
mLZ_regA_ReG_br<-multiLocalZscore(A = 
                                    AlienRSList_narrow$regA, 
                                  Blist = AlienRSList_broad, 
                                  ranFUN = "resampleGenome",
                                  genome = AlienGenome,
                                  window = 5000,
                                  step =100)
##
```
```{r}
mLZ_regA_ReG_br<-makeLZMatrix(mLZ_regA_ReG_br)

plotLocalZScoreMatrix(mLZ_regA_ReG_br)
```
# Session Info
```{r, sessionInfo}
sessionInfo()
```

